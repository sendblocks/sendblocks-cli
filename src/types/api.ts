/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/api/v1/contracts": {
    /** Get Analyzed Contract */
    get: operations["get_analyzed_contract_api_v1_contracts_get"];
    /** Analyze */
    post: operations["analyze_api_v1_contracts_post"];
  };
  "/api/v1/events": {
    /** Get Events */
    get: operations["get_events_api_v1_events_get"];
  };
  "/api/v1/stats": {
    /** Get Stats */
    get: operations["get_stats_api_v1_stats_get"];
  };
  "/api/v1/functions": {
    /** List Functions */
    get: operations["list_functions_api_v1_functions_get"];
    /** Create Function */
    post: operations["create_function_api_v1_functions_post"];
  };
  "/api/v1/functions/{id}": {
    /** Get Function Metadata */
    get: operations["get_function_metadata_api_v1_functions__id__get"];
    /** Delete Function */
    delete: operations["delete_function_api_v1_functions__id__delete"];
    /**
     * Update Function
     * @description Update function metadata, empty values wont be updated
     */
    patch: operations["update_function_api_v1_functions__id__patch"];
  };
  "/api/v1/functions/{id}/code": {
    /** Get Function Code */
    get: operations["get_function_code_api_v1_functions__id__code_get"];
  };
  "/api/v1/functions/{id}/test-run": {
    /** Invoke Function */
    post: operations["invoke_function_api_v1_functions__id__test_run_post"];
  };
  "/api/v1/functions/replay_blocks": {
    /** Replay Blocks */
    post: operations["replay_blocks_api_v1_functions_replay_blocks_post"];
  };
  "/api/v1/functions/{id}/stats": {
    /** Get Function Stats */
    get: operations["get_function_stats_api_v1_functions__id__stats_get"];
  };
  "/api/v1/data/nft/": {
    /** Get Nft For Owner */
    get: operations["get_nft_for_owner_api_v1_data_nft__get"];
  };
  "/api/v1/playground/run": {
    /** Run Playground */
    post: operations["run_playground_api_v1_playground_run_post"];
  };
  "/public/{id}": {
    /** Get Public Share */
    get: operations["get_public_share_public__id__get"];
    /** Public Shares Options Handler */
    options: operations["public_shares_options_handler_public__id__options"];
  };
  "/api/v1/risk/depeg/subscriptions": {
    /**
     * Get Depegging Subscriptions
     * @description Get all depegging subscriptions
     */
    get: operations["get_depegging_subscriptions_api_v1_risk_depeg_subscriptions_get"];
    /**
     * Create Depegging Subscription
     * @description Create a new depegging subscription
     */
    post: operations["create_depegging_subscription_api_v1_risk_depeg_subscriptions_post"];
  };
  "/api/v1/risk/depeg/subscriptions/{subscription_id}": {
    /**
     * Delete Depegging Subscription
     * @description Delete a depegging subscription
     */
    delete: operations["delete_depegging_subscription_api_v1_risk_depeg_subscriptions__subscription_id__delete"];
  };
  "/api/v1/risk/depeg/events": {
    /**
     * Get Depegging Events
     * @description Get all depegging events for a specific time period
     */
    get: operations["get_depegging_events_api_v1_risk_depeg_events_get"];
  };
  "/api/v1/risk/liquidity/subscriptions": {
    /**
     * Get Liquidity Ratio Subscriptions
     * @description Get all liquidity equality subscriptions
     */
    get: operations["get_liquidity_ratio_subscriptions_api_v1_risk_liquidity_subscriptions_get"];
    /**
     * Create Liquidity Ratio Subscription
     * @description Create a new liquidity equality subscription
     */
    post: operations["create_liquidity_ratio_subscription_api_v1_risk_liquidity_subscriptions_post"];
  };
  "/api/v1/risk/liquidity/subscriptions/{subscription_id}": {
    /**
     * Delete Liquidity Ratio Subscription
     * @description Delete a liquidity equality subscription
     */
    delete: operations["delete_liquidity_ratio_subscription_api_v1_risk_liquidity_subscriptions__subscription_id__delete"];
  };
  "/api/v1/risk/liquidity/events": {
    /**
     * Get Liquidity Equality Events
     * @description Get all liquidity equality events
     */
    get: operations["get_liquidity_equality_events_api_v1_risk_liquidity_events_get"];
  };
  "/api/v1/risk/concentration/subscriptions": {
    /**
     * Get Concentration Subscriptions
     * @description Get all concentration risk subscriptions
     */
    get: operations["get_concentration_subscriptions_api_v1_risk_concentration_subscriptions_get"];
    /**
     * Create Concentration Subscription
     * @description Create a concentration risk subscription
     */
    post: operations["create_concentration_subscription_api_v1_risk_concentration_subscriptions_post"];
  };
  "/api/v1/risk/concentration/subscriptions/{subscription_id}": {
    /**
     * Delete Concentration Subscription
     * @description Delete a concentration risk subscription
     */
    delete: operations["delete_concentration_subscription_api_v1_risk_concentration_subscriptions__subscription_id__delete"];
  };
  "/api/v1/risk/concentration/events": {
    /**
     * Get Concentration Events
     * @description Get concentration risk events
     */
    get: operations["get_concentration_events_api_v1_risk_concentration_events_get"];
  };
  "/api/v1/risk/anomaly/subscriptions": {
    /**
     * Get Anomaly Subscriptions
     * @description Get all anomaly subscriptions
     */
    get: operations["get_anomaly_subscriptions_api_v1_risk_anomaly_subscriptions_get"];
    /**
     * Create Anomaly Subscription
     * @description Create a new anomaly subscription
     */
    post: operations["create_anomaly_subscription_api_v1_risk_anomaly_subscriptions_post"];
  };
  "/api/v1/risk/anomaly/subscriptions/{subscription_id}": {
    /**
     * Delete Anomaly Subscription
     * @description Delete an anomaly subscription
     */
    delete: operations["delete_anomaly_subscription_api_v1_risk_anomaly_subscriptions__subscription_id__delete"];
  };
  "/api/v1/risk/anomaly/events": {
    /**
     * Get Anomaly Events
     * @description Get all anomaly events
     */
    get: operations["get_anomaly_events_api_v1_risk_anomaly_events_get"];
  };
  "/api/v1/risk/events": {
    /**
     * Get Risk Events
     * @description Get all risk events
     */
    get: operations["get_risk_events_api_v1_risk_events_get"];
  };
  "/api/v1/rpc_api_keys": {
    /** List Rpc Api Keys */
    get: operations["list_rpc_api_keys_api_v1_rpc_api_keys_get"];
  };
  "/api/v1/rpc_api_keys/{id}": {
    /** Get Rpc Api Key */
    get: operations["get_rpc_api_key_api_v1_rpc_api_keys__id__get"];
  };
  "/api/v1/storage/shares": {
    /** List Tenant Public Shares */
    get: operations["list_tenant_public_shares_api_v1_storage_shares_get"];
  };
  "/api/v1/storage/namespaces/{namespace_id}/shares": {
    /** List Namespace Public Shares */
    get: operations["list_namespace_public_shares_api_v1_storage_namespaces__namespace_id__shares_get"];
    /** Create Public Share */
    post: operations["create_public_share_api_v1_storage_namespaces__namespace_id__shares_post"];
  };
  "/api/v1/storage/namespaces/{namespace_id}/shares/{id}": {
    /** Get Public Share */
    get: operations["get_public_share_api_v1_storage_namespaces__namespace_id__shares__id__get"];
    /** Delete Public Share */
    delete: operations["delete_public_share_api_v1_storage_namespaces__namespace_id__shares__id__delete"];
  };
  "/api/v1/storage/namespaces": {
    /** List Tenant Namespaces */
    get: operations["list_tenant_namespaces_api_v1_storage_namespaces_get"];
  };
  "/api/v1/storage/namespaces/{namespace_id}/values": {
    /** Get Namespace Storage */
    get: operations["get_namespace_storage_api_v1_storage_namespaces__namespace_id__values_get"];
    /** Delete Namespace Storage */
    delete: operations["delete_namespace_storage_api_v1_storage_namespaces__namespace_id__values_delete"];
  };
  "/api/v1/storage/namespaces/{namespace_id}/values/{key}": {
    /** Get Key From Namespace Storage */
    get: operations["get_key_from_namespace_storage_api_v1_storage_namespaces__namespace_id__values__key__get"];
    /** Save Key In Namespace Storage */
    post: operations["save_key_in_namespace_storage_api_v1_storage_namespaces__namespace_id__values__key__post"];
    /** Delete Key From Namespace Storage */
    delete: operations["delete_key_from_namespace_storage_api_v1_storage_namespaces__namespace_id__values__key__delete"];
  };
  "/api/v1/webhooks": {
    /** List Webhooks */
    get: operations["list_webhooks_api_v1_webhooks_get"];
    /** Create Webhook */
    post: operations["create_webhook_api_v1_webhooks_post"];
  };
  "/api/v1/webhooks/{id}": {
    /** Get Webhook */
    get: operations["get_webhook_api_v1_webhooks__id__get"];
    /** Delete Webhooks */
    delete: operations["delete_webhooks_api_v1_webhooks__id__delete"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /** Address Trigger */
    AddressTriggerData: {
      /**
       * Type
       * @enum {string}
       */
      type: "TRIGGER_TYPE_ADDRESS";
      /**
       * Address
       * @description Address to set trigger on
       * @example 0x283af0b28c62c092c9727f1ee09c02ca627eb7f5
       */
      address: string;
      /**
       * Locations
       * @description Locations to set trigger on. Leave empty to set trigger on all locations.
       * @example [
       *   "trace_to",
       *   "trace_from"
       * ]
       */
      locations?: components["schemas"]["PydanticAddressLocations"][];
    };
    /** AnomalyEvent */
    AnomalyEvent: {
      /**
       * Chain
       * @description Chain which the alert was triggered on
       * @example CHAIN_ETH_MAINNET
       * @enum {string}
       */
      chain_id: "CHAIN_ETH_MAINNET" | "CHAIN_ETH_SEPOLIA" | "CHAIN_ARBITRUM_ONE" | "CHAIN_POLYGON_MAINNET" | "CHAIN_STARKNET_MAINNET" | "CHAIN_COSMOS_OSMOSIS" | "CHAIN_AURORA_MAINNET" | "CHAIN_BNB_MAINNET" | "CHAIN_BNB_TESTNET" | "CHAIN_MANTLE_MAINNET" | "CHAIN_SOLANA_MAINNET";
      /**
       * Stable Coin
       * @description The stable coin alerted in the event
       * @example USDT
       */
      stablecoin_id: components["schemas"]["StableCoins"];
      /**
       * Event Time
       * Format: date-time
       * @description The time of the event
       */
      event_time: string;
      /**
       * Anomaly Type
       * @description The type of the anomaly
       * @example NEW_CONTRACT_DEPLOYED
       */
      anomaly_type: components["schemas"]["AnomalyType"];
      /**
       * Anomaly Data
       * @description The data of the anomaly
       * @example {
       *   "contract_address": "0x1234567890",
       *   "deployer": "0x0987654321"
       * }
       */
      anomaly_data: Record<string, never>;
    };
    /**
     * AnomalyType
     * @description An enumeration.
     * @enum {string}
     */
    AnomalyType: "LARGE_TRANSFER" | "LARGE_WITHDRAW" | "SUSPICIOUS_ADDRESS_INVOLVEMENT" | "HACK_REPORTED" | "NEW_CONTRACT_DEPLOYED";
    /**
     * Chain
     * @description An enumeration.
     * @enum {unknown}
     */
    Chain: "1" | "11155111" | "42161" | "137" | "23448594291968334" | "osmosis-1" | "1313161554" | "56" | "97" | "5000" | "59144" | "solana-mainnet";
    /** ConcentrationEvent */
    ConcentrationEvent: {
      /**
       * Chain
       * @description The chain of the event
       * @example CHAIN_ETH_MAINNET
       */
      chain_id: components["schemas"]["SupportedChains"];
      /**
       * Stable Coin
       * @description The stable coin alerted in the event
       * @example USDC
       */
      stablecoin_id: components["schemas"]["StableCoins"];
      /**
       * Event Time
       * Format: date-time
       * @description The time of the event
       */
      event_time: string;
      /**
       * Holder Address
       * @description The holder address of the stable coin
       * @example 0x1234567890
       */
      holder_address: string;
      /**
       * Concentration
       * @description The concentration percentage of the stable coin
       * @example 0.6
       */
      concentration: number;
    };
    /** ConcentrationRiskGetReply */
    ConcentrationRiskGetReply: {
      /**
       * Subscription ID
       * @description The ID of the created subscription
       */
      subscription_id: string;
      /**
       * Chain
       * @description The chain to subscribe to
       * @example CHAIN_ETH_MAINNET
       */
      chain_id: components["schemas"]["SupportedChains"];
      /**
       * Stable Coin
       * @description The stable coin to be checked against in the subscription
       * @example USDC
       */
      stablecoin_id: components["schemas"]["StableCoins"];
      /**
       * Threshold
       * @description The threshold of concentration to trigger the alert
       * @example 0.6
       */
      threshold: number;
    };
    /** ConcentrationRiskSubRequest */
    ConcentrationRiskSubRequest: {
      /**
       * Chain
       * @description The chain to subscribe to
       * @example CHAIN_ETH_MAINNET
       */
      chain_id: components["schemas"]["SupportedChains"];
      /**
       * Stable Coin
       * @description The stable coin to be checked against in the subscription
       * @example USDC
       */
      stablecoin_id: components["schemas"]["StableCoins"];
      /**
       * Threshold
       * @description The threshold of concentration to trigger the alert
       * @example 0.6
       */
      threshold: number;
    };
    /** ContractRequest */
    ContractRequest: {
      /**
       * Chain
       * @description Chain for the function to run on
       * @default CHAIN_ETH_MAINNET
       * @example CHAIN_ETH_MAINNET
       * @enum {string}
       */
      chain_id?: "CHAIN_ETH_MAINNET" | "CHAIN_ETH_SEPOLIA" | "CHAIN_ARBITRUM_ONE" | "CHAIN_POLYGON_MAINNET" | "CHAIN_BNB_MAINNET" | "CHAIN_BNB_TESTNET";
      /**
       * Contract Address
       * @description EVM address of the contract
       * @example 0x283af0b28c62c092c9727f1ee09c02ca627eb7f5
       */
      contract_address: string;
    };
    /** CreateAnomalySubRequest */
    CreateAnomalySubRequest: {
      /**
       * Chain
       * @description Chain for the alert to run on
       * @example CHAIN_ETH_MAINNET
       * @enum {unknown}
       */
      chain_id: "CHAIN_ETH_MAINNET" | "CHAIN_ETH_SEPOLIA" | "CHAIN_ARBITRUM_ONE" | "CHAIN_POLYGON_MAINNET" | "CHAIN_STARKNET_MAINNET" | "CHAIN_COSMOS_OSMOSIS" | "CHAIN_AURORA_MAINNET" | "CHAIN_BNB_MAINNET" | "CHAIN_BNB_TESTNET" | "CHAIN_MANTLE_MAINNET" | "CHAIN_SOLANA_MAINNET";
      /**
       * Stable Coin
       * @description The stable coin to be checked against in the subscription
       * @example USDC
       */
      stablecoin_id: components["schemas"]["StableCoins"];
    };
    /** CreateDepegSubRequest */
    CreateDepegSubRequest: {
      /**
       * Alert Channel
       * @description The alert channel to be used for the subscription
       * @example {
       *   "url": "https://example.com",
       *   "secret": "secret"
       * }
       */
      alert_channel: components["schemas"]["WebhookChannel"] | components["schemas"]["TelegramChannel"] | components["schemas"]["SlackChannel"];
      /**
       * Chain
       * @description Chain for the function to run on
       * @example CHAIN_ETH_MAINNET
       * @enum {string}
       */
      chain_id: "CHAIN_ETH_MAINNET" | "CHAIN_ETH_SEPOLIA" | "CHAIN_ARBITRUM_ONE" | "CHAIN_POLYGON_MAINNET" | "CHAIN_STARKNET_MAINNET" | "CHAIN_COSMOS_OSMOSIS" | "CHAIN_AURORA_MAINNET" | "CHAIN_BNB_MAINNET" | "CHAIN_BNB_TESTNET" | "CHAIN_MANTLE_MAINNET" | "CHAIN_SOLANA_MAINNET";
      /**
       * Stable coin
       * @description The stable coin to be tracked in the subscription
       * @example USDT
       */
      stablecoin_id: components["schemas"]["StableCoins"];
      /**
       * Data Sources
       * @description List of data sources to used for tracking in the subscription
       * @example [
       *   "CHAINLINK_ORACLE",
       *   "COINGECKO"
       * ]
       */
      data_sources: components["schemas"]["DataProviders"][];
      /**
       * Threshold
       * @description The threshold value for the subscription
       */
      threshold: number;
    };
    /** CreateSubReply */
    CreateSubReply: {
      /**
       * Subscription ID
       * @description The ID of the created subscription
       */
      subscription_id: string;
    };
    /**
     * DEXs
     * @description An enumeration.
     * @enum {unknown}
     */
    DEXs: "UNISWAP" | "SUSHISWAP" | "PANCAKESWAP" | "CURVE";
    /**
     * DataProviders
     * @description An enumeration.
     * @enum {unknown}
     */
    DataProviders: "CHAINLINK_ORACLE" | "UNISWAP_ORACLE" | "COINGECKO" | "COINMARKETCAP";
    /**
     * DepeggingCauses
     * @description An enumeration.
     * @enum {unknown}
     */
    DepeggingCauses: "MARKET_MANIPULATION" | "LIQUIDITY_ISSUES" | "ORACLE_MANIPULATION" | "SECURITY_ISSUES" | "OTHER";
    /** DepeggingEvent */
    DepeggingEvent: {
      /**
       * Chain
       * @description Chain for the function to run on
       * @example CHAIN_ETH_MAINNET
       * @enum {string}
       */
      chain_id: "CHAIN_ETH_MAINNET" | "CHAIN_ETH_SEPOLIA" | "CHAIN_ARBITRUM_ONE" | "CHAIN_POLYGON_MAINNET" | "CHAIN_STARKNET_MAINNET" | "CHAIN_COSMOS_OSMOSIS" | "CHAIN_AURORA_MAINNET" | "CHAIN_BNB_MAINNET" | "CHAIN_BNB_TESTNET" | "CHAIN_MANTLE_MAINNET" | "CHAIN_SOLANA_MAINNET";
      /**
       * Stable coin
       * @description The stable coin to be tracked in the subscription
       * @example USDT
       */
      stablecoin_id: components["schemas"]["StableCoins"];
      /**
       * Event Time
       * Format: date-time
       * @description The time of the event
       */
      event_time: string;
      /**
       * Event Cause
       * @description The reason of the depegging event
       * @example ORACLE_MANIPULATION
       */
      event_cause: components["schemas"]["DepeggingCauses"];
      /**
       * Risk Level
       * @description The risk level of the event
       * @example HIGH
       */
      risk_level: components["schemas"]["RiskLevels"];
    };
    /** Event */
    Event: {
      /**
       * Event type
       * @description The type of the system event that occurred
       * @example EVENT_TYPE_RUN_FUNCTION
       * @enum {string}
       */
      event_type: "EVENT_TYPE_UNSPECIFIED" | "EVENT_TYPE_RUN_FUNCTION" | "EVENT_TYPE_WEBHOOK_RESPONSE";
      /** Timestamp */
      timestamp?: string;
      /** Payload */
      payload?: string;
    };
    /** Event Trigger */
    EventTriggerData: {
      /**
       * Type
       * @enum {string}
       */
      type: "TRIGGER_TYPE_EVENT";
      /**
       * Event
       * @description Event signature to set trigger on
       * @example 0x04fb42f6b9d37e87d9febc9946d24a6135f9d2435fd0e163eeb1e025817605b2
       */
      event: string;
    };
    /** ExecuteFunctionArgs */
    ExecuteFunctionArgs: {
      /** Context */
      context: Record<string, never>;
      /** Data */
      data: Record<string, never>;
    };
    /** FuncInfo */
    FuncInfo: {
      /** Chain Id */
      chain_id: string;
      /** Function Id */
      function_id: string;
      /** Triggers */
      triggers: (components["schemas"]["AddressTriggerData"] | components["schemas"]["EventTriggerData"] | components["schemas"]["FunctionTriggerData"] | components["schemas"]["NewBlockTriggerData"] | components["schemas"]["NewContractTriggerData"] | components["schemas"]["StorageTriggerData"])[];
      /** Webhook Id */
      webhook_id: string;
      /** Function Name */
      function_name: string;
      /** Is Enabled */
      is_enabled: boolean;
      /** Should Send Std Streams */
      should_send_std_streams: boolean;
      /** Function Code */
      function_code: string;
    };
    /** FuncInfoPatch */
    FuncInfoPatch: {
      /**
       * Function name
       * @description A descriptive function name
       * @example my_function
       */
      function_name?: string;
      /**
       * Is function enabled
       * @description Whether the function will be triggered or not
       * @default true
       * @example true
       */
      is_enabled?: boolean;
      /**
       * Webhook ID
       * @description Webhook ID as returned from SaveWebhook
       * @example 12345678-1234-1234-1234-123456789abc
       */
      webhook_id?: string;
      /**
       * Function code
       * @description You function code encoded in base 64
       * @example ZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyaWdnZXJIYW5kbGVyKGNvbnRleHQsIGRhdGEpIHsKICAgIHJldHVybiB7ImNvbnRleHQiOiBjb250ZXh0LCAiZGF0YSI6ZGF0YX07Cn0=
       */
      function_code?: string;
      /**
       * Should send stdout and stderr to webhook
       * @description Whether the result of the function stdout and stderr will be sent to the webhook in addition to the result of the function
       * @default true
       * @example true
       */
      should_send_std_streams?: boolean;
      /**
       * Triggers
       * @description Change the triggers that will invoke the function.
       */
      triggers?: (components["schemas"]["AddressTriggerData"] | components["schemas"]["EventTriggerData"] | components["schemas"]["FunctionTriggerData"] | components["schemas"]["NewBlockTriggerData"] | components["schemas"]["NewContractTriggerData"] | components["schemas"]["StorageTriggerData"])[];
    };
    /** Function Trigger */
    FunctionTriggerData: {
      /**
       * Type
       * @enum {string}
       */
      type: "TRIGGER_TYPE_FUNCTION";
      /**
       * Function
       * @description Function signature to set trigger on
       * @example 0xbeabacc8
       */
      function: string;
    };
    /** GetAnomalyEventsRequest */
    GetAnomalyEventsRequest: {
      /**
       * Start Date Time
       * Format: date-time
       * @description The start date time for the events
       */
      start_data_time: string;
      /**
       * End Date Time
       * Format: date-time
       * @description The end date time for the events
       */
      end_data_time: string;
      /**
       * Chains
       * @description The chain ids originating the events
       * @example [
       *   "CHAIN_ETH_MAINNET",
       *   "CHAIN_ARBITRUM_ONE"
       * ]
       */
      chain_ids: components["schemas"]["SupportedChains"][];
      /**
       * Stable Coins
       * @description The stable coins to retrieve events for
       * @example [
       *   "USDT",
       *   "USDC"
       * ]
       */
      stablecoin_ids: components["schemas"]["StableCoins"][];
    };
    /** GetAnomalySubReply */
    GetAnomalySubReply: {
      /**
       * Subscription ID
       * @description The ID of the created subscription
       */
      subscription_id: string;
      /**
       * Chain
       * @description Chain for the alert to run on
       * @example CHAIN_ETH_MAINNET
       * @enum {unknown}
       */
      chain_id: "CHAIN_ETH_MAINNET" | "CHAIN_ETH_SEPOLIA" | "CHAIN_ARBITRUM_ONE" | "CHAIN_POLYGON_MAINNET" | "CHAIN_STARKNET_MAINNET" | "CHAIN_COSMOS_OSMOSIS" | "CHAIN_AURORA_MAINNET" | "CHAIN_BNB_MAINNET" | "CHAIN_BNB_TESTNET" | "CHAIN_MANTLE_MAINNET" | "CHAIN_SOLANA_MAINNET";
      /**
       * Stable Coin
       * @description The stable coin to be checked against in the subscription
       * @example USDC
       */
      stablecoin_id: components["schemas"]["StableCoins"];
    };
    /** GetConcentrationEventsRequest */
    GetConcentrationEventsRequest: {
      /**
       * Start Date Time
       * Format: date-time
       * @description The start date time for the events
       */
      start_data_time: string;
      /**
       * End Date Time
       * Format: date-time
       * @description The end date time for the events
       */
      end_data_time: string;
      /**
       * Chains
       * @description The chain ids originating the events
       * @example [
       *   "CHAIN_ETH_MAINNET",
       *   "CHAIN_POLYGON_MAINNET"
       * ]
       */
      chain_ids: components["schemas"]["SupportedChains"][];
      /**
       * Stable Coins
       * @description The stable coins to retrieve events for
       * @example [
       *   "DAI",
       *   "USDC"
       * ]
       */
      stablecoin_ids: components["schemas"]["StableCoins"][];
    };
    /** GetDepegSubscriptionReply */
    GetDepegSubscriptionReply: {
      /**
       * Subscription ID
       * @description The ID of the created subscription
       */
      subscription_id: string;
      /**
       * Alert Channel
       * @description The alert channel to be used for the subscription
       * @example {
       *   "url": "https://example.com",
       *   "secret": "secret"
       * }
       */
      alert_channel: components["schemas"]["WebhookChannel"] | components["schemas"]["TelegramChannel"] | components["schemas"]["SlackChannel"];
      /**
       * Chain
       * @description Chain for the function to run on
       * @example CHAIN_ETH_MAINNET
       * @enum {string}
       */
      chain_id: "CHAIN_ETH_MAINNET" | "CHAIN_ETH_SEPOLIA" | "CHAIN_ARBITRUM_ONE" | "CHAIN_POLYGON_MAINNET" | "CHAIN_STARKNET_MAINNET" | "CHAIN_COSMOS_OSMOSIS" | "CHAIN_AURORA_MAINNET" | "CHAIN_BNB_MAINNET" | "CHAIN_BNB_TESTNET" | "CHAIN_MANTLE_MAINNET" | "CHAIN_SOLANA_MAINNET";
      /**
       * Stable coin
       * @description The stable coin to be tracked in the subscription
       * @example USDT
       */
      stablecoin_id: components["schemas"]["StableCoins"];
      /**
       * Data Sources
       * @description List of data sources to used for tracking in the subscription
       * @example [
       *   "CHAINLINK_ORACLE",
       *   "COINGECKO"
       * ]
       */
      data_sources: components["schemas"]["DataProviders"][];
      /**
       * Threshold
       * @description The threshold value for the subscription
       */
      threshold: number;
    };
    /** GetDepeggingEventsRequest */
    GetDepeggingEventsRequest: {
      /**
       * Chains
       * @description The chain ids originating the events
       * @example [
       *   "CHAIN_ETH_MAINNET",
       *   "CHAIN_BNB_MAINNET"
       * ]
       */
      chain_ids: components["schemas"]["SupportedChains"][];
      /**
       * Start Date Time
       * Format: date-time
       * @description The start date time for the events
       */
      start_data_time: string;
      /**
       * End Date Time
       * Format: date-time
       * @description The end date time for the events
       */
      end_data_time: string;
      /**
       * Stable Coins
       * @description List of stable coins to be included in the events
       * @example [
       *   "USDT",
       *   "USDC"
       * ]
       */
      stable_coins: components["schemas"]["StableCoins"][];
    };
    /** GetLiqSubReply */
    GetLiqSubReply: {
      /**
       * Subscription ID
       * @description The ID of the created subscription
       */
      subscription_id: string;
      /**
       * Chain
       * @description Chain for the alert to run on
       * @example CHAIN_ETH_MAINNET
       * @enum {unknown}
       */
      chain_id: "CHAIN_ETH_MAINNET" | "CHAIN_ETH_SEPOLIA" | "CHAIN_ARBITRUM_ONE" | "CHAIN_POLYGON_MAINNET" | "CHAIN_STARKNET_MAINNET" | "CHAIN_COSMOS_OSMOSIS" | "CHAIN_AURORA_MAINNET" | "CHAIN_BNB_MAINNET" | "CHAIN_BNB_TESTNET" | "CHAIN_MANTLE_MAINNET" | "CHAIN_SOLANA_MAINNET";
      /**
       * Alerted Stable Coin
       * @description The stable coin to be tracked in the subscription
       * @example USDT
       */
      alerted_stable_coin: components["schemas"]["StableCoins"];
      /**
       * Checked Stable Coin
       * @description The stable coin to be checked against in the subscription
       * @example USDC
       */
      checked_stable_coin: components["schemas"]["StableCoins"];
      /**
       * DEX
       * @description The DEX to be used for the pool tracked in the subscription
       * @example UNISWAP
       */
      dex: components["schemas"]["DEXs"];
      /**
       * Liquidity Ratio Threshold
       * @description The threshold for the liquidity ratio
       * @example 0.9
       */
      liquidity_ratio_threshold: number;
    };
    /** GetLiquidityEventsRequest */
    GetLiquidityEventsRequest: {
      /**
       * Start Date Time
       * Format: date-time
       * @description The start date time for the events
       */
      start_data_time: string;
      /**
       * End Date Time
       * Format: date-time
       * @description The end date time for the events
       */
      end_data_time: string;
      /**
       * Chains
       * @description The chain ids originating the events
       * @example [
       *   "CHAIN_ETH_MAINNET",
       *   "CHAIN_ARBITRUM_ONE"
       * ]
       */
      chain_ids: components["schemas"]["SupportedChains"][];
      /**
       * Stable Coins
       * @description The stable coins to retrieve events for
       * @example [
       *   "USDT",
       *   "USDC"
       * ]
       */
      stablecoin_ids: components["schemas"]["StableCoins"][];
    };
    /** GetRiskEventsRequest */
    GetRiskEventsRequest: {
      /**
       * Start Date Time
       * Format: date-time
       * @description The start date time for the events
       */
      start_data_time: string;
      /**
       * End Date Time
       * Format: date-time
       * @description The end date time for the events
       */
      end_data_time: string;
      /**
       * Chains
       * @description The chain ids originating the events
       * @example [
       *   "CHAIN_ETH_MAINNET",
       *   "CHAIN_ARBITRUM_ONE"
       * ]
       */
      chain_ids: components["schemas"]["SupportedChains"][];
      /**
       * Stable Coins
       * @description The stable coins to retrieve events for
       * @example [
       *   "USDT",
       *   "USDC"
       * ]
       */
      stablecoin_ids: components["schemas"]["StableCoins"][];
    };
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Detail */
      detail?: components["schemas"]["ValidationError"][];
    };
    /** LiquidityEqualityEvent */
    LiquidityEqualityEvent: {
      /**
       * Chain
       * @description Chain which the alert was triggered on
       * @example CHAIN_ETH_MAINNET
       * @enum {string}
       */
      chain_id: "CHAIN_ETH_MAINNET" | "CHAIN_ETH_SEPOLIA" | "CHAIN_ARBITRUM_ONE" | "CHAIN_POLYGON_MAINNET" | "CHAIN_STARKNET_MAINNET" | "CHAIN_COSMOS_OSMOSIS" | "CHAIN_AURORA_MAINNET" | "CHAIN_BNB_MAINNET" | "CHAIN_BNB_TESTNET" | "CHAIN_MANTLE_MAINNET" | "CHAIN_SOLANA_MAINNET";
      /**
       * Stable coin
       * @description The stable coin alerted in the event
       * @example USDT
       */
      alerted_stablecoin_id: components["schemas"]["StableCoins"];
      /**
       * Checked Stable Coin
       * @description The stable coin to be checked against in the event
       * @example USDC
       */
      checked_stablecoin_id: components["schemas"]["StableCoins"];
      /**
       * Event Time
       * Format: date-time
       * @description The time of the event
       */
      event_time: string;
      /**
       * Liquidity Equality Ratio
       * @description The liquidity equality ratio
       * @example 0.9
       */
      liquidity_equality_ration: number;
    };
    /** New Block Trigger */
    NewBlockTriggerData: {
      /**
       * Type
       * @enum {string}
       */
      type: "TRIGGER_TYPE_NEW_BLOCK";
    };
    /** New Contract Trigger */
    NewContractTriggerData: {
      /**
       * Type
       * @enum {string}
       */
      type: "TRIGGER_TYPE_NEW_CONTRACT";
    };
    /** Page[Event] */
    Page_Event_: {
      /** Items */
      items: components["schemas"]["Event"][];
      /** Total */
      total?: number;
      /** Page */
      page?: number;
      /** Size */
      size?: number;
      /** Pages */
      pages?: number;
    };
    /** Page[FuncInfo] */
    Page_FuncInfo_: {
      /** Items */
      items: components["schemas"]["FuncInfo"][];
      /** Total */
      total?: number;
      /** Page */
      page?: number;
      /** Size */
      size?: number;
      /** Pages */
      pages?: number;
    };
    /** Page[PublicShareInfo] */
    Page_PublicShareInfo_: {
      /** Items */
      items: components["schemas"]["PublicShareInfo"][];
      /** Total */
      total?: number;
      /** Page */
      page?: number;
      /** Size */
      size?: number;
      /** Pages */
      pages?: number;
    };
    /** Page[RpcApiKeyId] */
    Page_RpcApiKeyId_: {
      /** Items */
      items: components["schemas"]["RpcApiKeyId"][];
      /** Total */
      total?: number;
      /** Page */
      page?: number;
      /** Size */
      size?: number;
      /** Pages */
      pages?: number;
    };
    /** Page[Stat] */
    Page_Stat_: {
      /** Items */
      items: components["schemas"]["Stat"][];
      /** Total */
      total?: number;
      /** Page */
      page?: number;
      /** Size */
      size?: number;
      /** Pages */
      pages?: number;
    };
    /** Page[VariableStorageMapping] */
    Page_VariableStorageMapping_: {
      /** Items */
      items: components["schemas"]["VariableStorageMapping"][];
      /** Total */
      total?: number;
      /** Page */
      page?: number;
      /** Size */
      size?: number;
      /** Pages */
      pages?: number;
    };
    /** Page[WebhookInfo] */
    Page_WebhookInfo_: {
      /** Items */
      items: components["schemas"]["WebhookInfo"][];
      /** Total */
      total?: number;
      /** Page */
      page?: number;
      /** Size */
      size?: number;
      /** Pages */
      pages?: number;
    };
    /** PlaygroundFunctionData */
    PlaygroundFunctionData: {
      /** Code */
      code: string;
      /** Context */
      context: Record<string, never>;
      /** Data */
      data: Record<string, never>;
      /** Sendstdstreams */
      sendStdStreams: boolean;
    };
    /** PublicShareInfo */
    PublicShareInfo: {
      /** Public Share Id */
      public_share_id: string;
      /** Namespace Id */
      namespace_id: string;
      /** Description */
      description: string;
      /** Enabled */
      enabled: boolean;
      /** Url */
      url?: string;
    };
    /**
     * PydanticAddressLocations
     * @description An enumeration.
     * @enum {unknown}
     */
    PydanticAddressLocations: "trace_to" | "trace_from" | "trace_input" | "trace_output" | "log_emitter" | "log_topic" | "log_data" | "storage_key" | "storage_value" | "storage_address" | "event_attribute";
    /** ReplayBlocksParams */
    ReplayBlocksParams: {
      /**
       * Functions
       * @description List of function IDs to replay
       */
      functions: string[];
      /**
       * Chain
       * @description The chain from which blocks will be replayed
       * @default CHAIN_ETH_MAINNET
       * @example CHAIN_ETH_MAINNET
       * @enum {string}
       */
      chain_id?: "CHAIN_ETH_MAINNET" | "CHAIN_ETH_SEPOLIA" | "CHAIN_ARBITRUM_ONE" | "CHAIN_POLYGON_MAINNET" | "CHAIN_STARKNET_MAINNET" | "CHAIN_COSMOS_OSMOSIS" | "CHAIN_AURORA_MAINNET" | "CHAIN_BNB_MAINNET" | "CHAIN_BNB_TESTNET" | "CHAIN_MANTLE_MAINNET" | "CHAIN_SOLANA_MAINNET";
      /**
       * StartBlockNumber
       * @description The first block number that will be replayed
       */
      start_block_number: number;
      /**
       * EndBlockNumber
       * @description The last block number that will be replayed
       */
      end_block_number: number;
      /**
       * XLFlag
       * @description If true, invokes extended replay. This is used when replaying a large number of blocks
       * @default false
       */
      xl_flag?: boolean;
    };
    /**
     * RiskLevels
     * @description An enumeration.
     * @enum {unknown}
     */
    RiskLevels: "LOW" | "MEDIUM" | "HIGH";
    /** RpcApiKeyId */
    RpcApiKeyId: {
      /** Api Key Id */
      api_key_id: string;
    };
    /** RpcApiKeyInfo */
    RpcApiKeyInfo: {
      /** Api Key Id */
      api_key_id: string;
      /** Description */
      description: string;
      /** Api Key Value */
      api_key_value: string;
      /** Usages */
      usages: components["schemas"]["Usage"][];
      /** Usage Start Date */
      usage_start_date: string;
      /** Usage End Date */
      usage_end_date: string;
    };
    /** SaveFunctionRequest */
    SaveFunctionRequest: {
      /**
       * Chain
       * @description Chain for the function to run on
       * @default CHAIN_ETH_MAINNET
       * @example CHAIN_ETH_MAINNET
       * @enum {string}
       */
      chain_id?: "CHAIN_ETH_MAINNET" | "CHAIN_ETH_SEPOLIA" | "CHAIN_ARBITRUM_ONE" | "CHAIN_POLYGON_MAINNET" | "CHAIN_STARKNET_MAINNET" | "CHAIN_COSMOS_OSMOSIS" | "CHAIN_AURORA_MAINNET" | "CHAIN_BNB_MAINNET" | "CHAIN_BNB_TESTNET" | "CHAIN_MANTLE_MAINNET" | "CHAIN_SOLANA_MAINNET";
      /**
       * Triggers
       * @description Triggers that will invoke the function
       */
      triggers: (components["schemas"]["AddressTriggerData"] | components["schemas"]["EventTriggerData"] | components["schemas"]["FunctionTriggerData"] | components["schemas"]["NewBlockTriggerData"] | components["schemas"]["NewContractTriggerData"] | components["schemas"]["StorageTriggerData"])[];
      /**
       * Webhook ID
       * @description Webhook ID as returned from SaveWebhook
       * @example 12345678-1234-1234-1234-123456789abc
       */
      webhook_id: string;
      /**
       * Function name
       * @description A name to identify the function, must be unique per tenant
       * @example my_function
       */
      function_name: string;
      /**
       * Function code
       * @description You function code encoded in base 64
       * @example ZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyaWdnZXJIYW5kbGVyKGNvbnRleHQsIGRhdGEpIHsKICAgIHJldHVybiB7ImNvbnRleHQiOiBjb250ZXh0LCAiZGF0YSI6ZGF0YX07Cn0=
       */
      function_code: string;
      /**
       * Should send stdout and stderr to webhook
       * @description Whether the result of the function stdout and stderr will be sent to the webhook in addition to the result of the function
       * @default true
       * @example true
       */
      should_send_std_streams?: boolean;
    };
    /** SaveFunctionResponse */
    SaveFunctionResponse: {
      /** Function Id */
      function_id?: string;
    };
    /** SavePublicShareRequest */
    SavePublicShareRequest: {
      /**
       * Description
       * @description A description of the public share
       * @example This is a public share
       */
      description: string;
      /**
       * Enabled
       * @description Whether the public share is enabled
       * @example true
       */
      enabled: boolean;
    };
    /** SavePublicShareResponse */
    SavePublicShareResponse: {
      /** Public Share Id */
      public_share_id?: string;
    };
    /** SaveWebhookRequest */
    SaveWebhookRequest: {
      /**
       * Webhook URL
       * @description A URL to post output of a function
       * @example https://example.com/webhook
       */
      url: string;
      /**
       * Webhook secret
       * @description A secret to pass in Authorization header when posting
       * @example secret
       */
      secret: string;
      /**
       * Webhook name
       * @description A name to identify the webhook, must be unique per tenant
       * @example webhook_name
       */
      webhook_name: string;
    };
    /** SaveWebhookResponse */
    SaveWebhookResponse: {
      /** Webhook Id */
      webhook_id?: string;
    };
    /** SlackChannel */
    SlackChannel: {
      /** Webhook Url */
      webhook_url: string;
    };
    /**
     * StableCoins
     * @description An enumeration.
     * @enum {unknown}
     */
    StableCoins: "USDT" | "USDC" | "DAI";
    /** Stat */
    Stat: {
      /** Tenant Id */
      tenant_id?: string;
      /** Start Time */
      start_time?: string;
      /** End Time */
      end_time?: string;
      /**
       * Interval
       * @description The time interval for the stats
       * @example STAT_INTERVAL_HOUR
       * @enum {string}
       */
      interval: "STAT_INTERVAL_UNSPECIFIED" | "STAT_INTERVAL_HOUR" | "STAT_INTERVAL_DAY" | "STAT_INTERVAL_WEEK" | "STAT_INTERVAL_MONTH";
      /**
       * Event type
       * @description The type of the system event that occurred
       * @example EVENT_TYPE_RUN_FUNCTION
       * @enum {string}
       */
      event_type: "EVENT_TYPE_UNSPECIFIED" | "EVENT_TYPE_RUN_FUNCTION" | "EVENT_TYPE_WEBHOOK_RESPONSE";
      /** Func Id */
      func_id?: string;
      /** Webhook Id */
      webhook_id?: string;
      /** Stats */
      stats?: string;
    };
    /** By Slot */
    StorageSlotTrigger: {
      /**
       * Slot
       * @description Hex encoded slot value
       * @example 0x4567
       */
      variable_slot: string;
    };
    /** Storage Trigger */
    StorageTriggerData: {
      /**
       * Type
       * @enum {string}
       */
      type: "TRIGGER_TYPE_STORAGE_ACCESS";
      /**
       * Storage Address
       * @description Address to watch for storage changes
       * @example 0x4db1f25d3d98600140dfc18deb7515be5bd293af
       */
      storage_address: string;
      /**
       * Follow Proxy
       * @description Should we search for a variable name in an implementation contract
       * @default true
       */
      follow_proxy?: boolean;
      /** Variable */
      variable: components["schemas"]["StorageVariableTrigger"] | components["schemas"]["StorageSlotTrigger"];
    };
    /** By Variable Name */
    StorageVariableTrigger: {
      /**
       * Variable Name
       * @description Name of variable to watch for changes
       * @example totalSupply
       */
      variable_name: string;
    };
    /**
     * SupportedChains
     * @description An enumeration.
     * @enum {unknown}
     */
    SupportedChains: "CHAIN_ETH_MAINNET" | "CHAIN_ETH_SEPOLIA" | "CHAIN_ARBITRUM_ONE" | "CHAIN_POLYGON_MAINNET" | "CHAIN_STARKNET_MAINNET" | "CHAIN_COSMOS_OSMOSIS" | "CHAIN_AURORA_MAINNET" | "CHAIN_BNB_MAINNET" | "CHAIN_BNB_TESTNET" | "CHAIN_MANTLE_MAINNET" | "CHAIN_LINEA_MAINNET" | "CHAIN_SOLANA_MAINNET";
    /** TelegramChannel */
    TelegramChannel: {
      /** Webhook Url */
      webhook_url: string;
    };
    /** Usage */
    Usage: {
      /** Usage Plan Name */
      usage_plan_name: string;
      /** Period */
      period: string;
      /** Quota */
      quota: number;
      /** Usage Entries */
      usage_entries: components["schemas"]["UsageEntry"][];
    };
    /** UsageEntry */
    UsageEntry: {
      /** Used */
      used: number;
      /** Remaining */
      remaining: number;
    };
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: (string | number)[];
      /** Message */
      msg: string;
      /** Error Type */
      type: string;
    };
    /** VariableStorageMapping */
    VariableStorageMapping: {
      /** Name */
      name?: string;
      /** First Slot */
      first_slot?: string;
      /** Last Slot */
      last_slot?: string;
    };
    /** WebhookChannel */
    WebhookChannel: {
      /** Url */
      url: string;
      /** Secret */
      secret: string;
    };
    /** WebhookInfo */
    WebhookInfo: {
      /** Url */
      url: string;
      /** Secret */
      secret: string;
      /** Webhook Id */
      webhook_id: string;
      /** Webhook Name */
      webhook_name: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /** Get Analyzed Contract */
  get_analyzed_contract_api_v1_contracts_get: {
    parameters: {
      query: {
        /**
         * @description Chain for the function to run on
         * @example CHAIN_ETH_MAINNET
         */
        chain_id?: "CHAIN_ETH_MAINNET" | "CHAIN_ETH_SEPOLIA" | "CHAIN_ARBITRUM_ONE" | "CHAIN_POLYGON_MAINNET" | "CHAIN_BNB_MAINNET" | "CHAIN_BNB_TESTNET";
        /**
         * @description EVM address of the contract
         * @example 0x283af0b28c62c092c9727f1ee09c02ca627eb7f5
         */
        contract_address: string;
        /** @description Should we fetch the analyzed implementation contract */
        follow_proxy?: boolean;
        page?: number;
        size?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_VariableStorageMapping_"];
        };
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Analyze */
  analyze_api_v1_contracts_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ContractRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Get Events */
  get_events_api_v1_events_get: {
    parameters: {
      query?: {
        func_id?: string;
        status_filter?: string;
        type_filter?: string;
        page?: number;
        size?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_Event_"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Get Stats */
  get_stats_api_v1_stats_get: {
    parameters: {
      query?: {
        start_time?: string;
        end_time?: string;
        type_filter?: string;
        function_id?: string;
        webhook_id?: string;
        page?: number;
        size?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_Stat_"];
        };
      };
      /** @description Statistics not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** List Functions */
  list_functions_api_v1_functions_get: {
    parameters: {
      query?: {
        page?: number;
        size?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_FuncInfo_"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Create Function */
  create_function_api_v1_functions_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SaveFunctionRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["SaveFunctionResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Get Function Metadata */
  get_function_metadata_api_v1_functions__id__get: {
    parameters: {
      query?: {
        include_function_code?: boolean;
      };
      path: {
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FuncInfo"];
        };
      };
      /** @description Function not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Delete Function */
  delete_function_api_v1_functions__id__delete: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FuncInfo"];
        };
      };
      /** @description Function not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Update Function
   * @description Update function metadata, empty values wont be updated
   */
  update_function_api_v1_functions__id__patch: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["FuncInfoPatch"];
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Function not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Get Function Code */
  get_function_code_api_v1_functions__id__code_get: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description Function code */
      200: {
        content: {
          "application/octet-stream": unknown;
        };
      };
      /** @description Function not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Invoke Function */
  invoke_function_api_v1_functions__id__test_run_post: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ExecuteFunctionArgs"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
      /** @description Function not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Replay Blocks */
  replay_blocks_api_v1_functions_replay_blocks_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReplayBlocksParams"];
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description invalid input */
      400: {
        content: never;
      };
      /** @description Function not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Get Function Stats */
  get_function_stats_api_v1_functions__id__stats_get: {
    parameters: {
      query?: {
        start_time?: string;
        end_time?: string;
        type_filter?: string;
        page?: number;
        size?: number;
      };
      path: {
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_Stat_"];
        };
      };
      /** @description Function or its statistics not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Get Nft For Owner */
  get_nft_for_owner_api_v1_data_nft__get: {
    parameters: {
      query: {
        owner: string;
        /**
         * @description Chain that the address is on
         * @example CHAIN_STARKNET_MAINNET
         */
        chain: "CHAIN_STARKNET_MAINNET";
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Bad arguments */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Run Playground */
  run_playground_api_v1_playground_run_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["PlaygroundFunctionData"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get Public Share */
  get_public_share_public__id__get: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Data not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Public Shares Options Handler */
  public_shares_options_handler_public__id__options: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Depegging Subscriptions
   * @description Get all depegging subscriptions
   */
  get_depegging_subscriptions_api_v1_risk_depeg_subscriptions_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["GetDepegSubscriptionReply"][];
        };
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Create Depegging Subscription
   * @description Create a new depegging subscription
   */
  create_depegging_subscription_api_v1_risk_depeg_subscriptions_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDepegSubRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["CreateSubReply"];
        };
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Delete Depegging Subscription
   * @description Delete a depegging subscription
   */
  delete_depegging_subscription_api_v1_risk_depeg_subscriptions__subscription_id__delete: {
    parameters: {
      path: {
        subscription_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Get Depegging Events
   * @description Get all depegging events for a specific time period
   */
  get_depegging_events_api_v1_risk_depeg_events_get: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["GetDepeggingEventsRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["DepeggingEvent"][];
        };
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Get Liquidity Ratio Subscriptions
   * @description Get all liquidity equality subscriptions
   */
  get_liquidity_ratio_subscriptions_api_v1_risk_liquidity_subscriptions_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["GetLiqSubReply"][];
        };
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Create Liquidity Ratio Subscription
   * @description Create a new liquidity equality subscription
   */
  create_liquidity_ratio_subscription_api_v1_risk_liquidity_subscriptions_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDepegSubRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["CreateSubReply"];
        };
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Delete Liquidity Ratio Subscription
   * @description Delete a liquidity equality subscription
   */
  delete_liquidity_ratio_subscription_api_v1_risk_liquidity_subscriptions__subscription_id__delete: {
    parameters: {
      path: {
        subscription_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Get Liquidity Equality Events
   * @description Get all liquidity equality events
   */
  get_liquidity_equality_events_api_v1_risk_liquidity_events_get: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["GetLiquidityEventsRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["LiquidityEqualityEvent"][];
        };
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Get Concentration Subscriptions
   * @description Get all concentration risk subscriptions
   */
  get_concentration_subscriptions_api_v1_risk_concentration_subscriptions_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ConcentrationRiskGetReply"][];
        };
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Create Concentration Subscription
   * @description Create a concentration risk subscription
   */
  create_concentration_subscription_api_v1_risk_concentration_subscriptions_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConcentrationRiskSubRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["CreateSubReply"];
        };
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Delete Concentration Subscription
   * @description Delete a concentration risk subscription
   */
  delete_concentration_subscription_api_v1_risk_concentration_subscriptions__subscription_id__delete: {
    parameters: {
      path: {
        subscription_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Get Concentration Events
   * @description Get concentration risk events
   */
  get_concentration_events_api_v1_risk_concentration_events_get: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["GetConcentrationEventsRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ConcentrationEvent"][];
        };
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Get Anomaly Subscriptions
   * @description Get all anomaly subscriptions
   */
  get_anomaly_subscriptions_api_v1_risk_anomaly_subscriptions_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["GetAnomalySubReply"][];
        };
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Create Anomaly Subscription
   * @description Create a new anomaly subscription
   */
  create_anomaly_subscription_api_v1_risk_anomaly_subscriptions_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateAnomalySubRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["CreateSubReply"];
        };
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Delete Anomaly Subscription
   * @description Delete an anomaly subscription
   */
  delete_anomaly_subscription_api_v1_risk_anomaly_subscriptions__subscription_id__delete: {
    parameters: {
      path: {
        subscription_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Get Anomaly Events
   * @description Get all anomaly events
   */
  get_anomaly_events_api_v1_risk_anomaly_events_get: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["GetAnomalyEventsRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["AnomalyEvent"][];
        };
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Get Risk Events
   * @description Get all risk events
   */
  get_risk_events_api_v1_risk_events_get: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["GetRiskEventsRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": (components["schemas"]["AnomalyEvent"] | components["schemas"]["LiquidityEqualityEvent"] | components["schemas"]["DepeggingEvent"])[];
        };
      };
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** List Rpc Api Keys */
  list_rpc_api_keys_api_v1_rpc_api_keys_get: {
    parameters: {
      query?: {
        page?: number;
        size?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_RpcApiKeyId_"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Get Rpc Api Key */
  get_rpc_api_key_api_v1_rpc_api_keys__id__get: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["RpcApiKeyInfo"];
        };
      };
      /** @description RPC API key not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** List Tenant Public Shares */
  list_tenant_public_shares_api_v1_storage_shares_get: {
    parameters: {
      query?: {
        page?: number;
        size?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_PublicShareInfo_"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** List Namespace Public Shares */
  list_namespace_public_shares_api_v1_storage_namespaces__namespace_id__shares_get: {
    parameters: {
      query?: {
        page?: number;
        size?: number;
      };
      path: {
        namespace_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_PublicShareInfo_"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Create Public Share */
  create_public_share_api_v1_storage_namespaces__namespace_id__shares_post: {
    parameters: {
      path: {
        namespace_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SavePublicShareRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["SavePublicShareResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Get Public Share */
  get_public_share_api_v1_storage_namespaces__namespace_id__shares__id__get: {
    parameters: {
      path: {
        namespace_id: string;
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PublicShareInfo"];
        };
      };
      /** @description Public share not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Delete Public Share */
  delete_public_share_api_v1_storage_namespaces__namespace_id__shares__id__delete: {
    parameters: {
      path: {
        namespace_id: string;
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PublicShareInfo"];
        };
      };
      /** @description Public share not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** List Tenant Namespaces */
  list_tenant_namespaces_api_v1_storage_namespaces_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": string[];
        };
      };
      /** @description No storage namespaces found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Get Namespace Storage */
  get_namespace_storage_api_v1_storage_namespaces__namespace_id__values_get: {
    parameters: {
      path: {
        namespace_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Namespace storage not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Delete Namespace Storage */
  delete_namespace_storage_api_v1_storage_namespaces__namespace_id__values_delete: {
    parameters: {
      path: {
        namespace_id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: never;
      };
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Namespace storage not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Get Key From Namespace Storage */
  get_key_from_namespace_storage_api_v1_storage_namespaces__namespace_id__values__key__get: {
    parameters: {
      path: {
        namespace_id: string;
        key: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Namespace storage not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Save Key In Namespace Storage */
  save_key_in_namespace_storage_api_v1_storage_namespaces__namespace_id__values__key__post: {
    parameters: {
      path: {
        namespace_id: string;
        key: string;
      };
    };
    requestBody: {
      content: {
        "application/json": string;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Namespace storage not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Delete Key From Namespace Storage */
  delete_key_from_namespace_storage_api_v1_storage_namespaces__namespace_id__values__key__delete: {
    parameters: {
      path: {
        namespace_id: string;
        key: string;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Namespace storage / key not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** List Webhooks */
  list_webhooks_api_v1_webhooks_get: {
    parameters: {
      query?: {
        page?: number;
        size?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_WebhookInfo_"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Create Webhook */
  create_webhook_api_v1_webhooks_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SaveWebhookRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["SaveWebhookResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Get Webhook */
  get_webhook_api_v1_webhooks__id__get: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["WebhookInfo"];
        };
      };
      /** @description Webhook not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /** Delete Webhooks */
  delete_webhooks_api_v1_webhooks__id__delete: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["WebhookInfo"];
        };
      };
      /** @description Webhook not found */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
}
